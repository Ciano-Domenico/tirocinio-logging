# logstash/pipeline/nginx.conf
input {
  # Lettura file di log Nginx
  file {
    path => "/var/log/nginx/access.log"
    start_position => "beginning"
    sincedb_path => "/usr/share/logstash/sincedb_nginx_access"
    codec => "json"
    type => "nginx_access"
    tags => ["nginx", "access", "proxy"]
  }

  file {
    path => "/var/log/nginx/error.log"
    start_position => "beginning"
    sincedb_path => "/usr/share/logstash/sincedb_nginx_error"
    type => "nginx_error"
    tags => ["nginx", "error", "proxy"]
  }

  # Input HTTP per log personalizzati
  http {
    port => 5000
    codec => json
    type => "custom_log"
    tags => ["custom", "http"]
  }

  # Input per Beats (opzionale per future espansioni)
  beats {
    port => 5044
    type => "beats"
  }
}

filter {
  # Filtri per log di accesso Nginx (JSON)
  if [type] == "nginx_access" {
    # I log sono giÃ  in formato JSON, aggiungiamo solo metadati
    mutate {
      add_field => { "service" => "nginx-proxy" }
      add_field => { "environment" => "development" }
      add_field => { "log_source" => "nginx_access" }
    }

    # Parsing dello status code per categorizzazione
    if [status] {
      if [status] >= 200 and [status] < 300 {
        mutate { add_field => { "status_category" => "success" } }
      } else if [status] >= 300 and [status] < 400 {
        mutate { add_field => { "status_category" => "redirect" } }
      } else if [status] >= 400 and [status] < 500 {
        mutate { add_field => { "status_category" => "client_error" } }
      } else if [status] >= 500 {
        mutate { add_field => { "status_category" => "server_error" } }
      }
    }

    # Parsing dell'URL per identificare il servizio target
    if [request] {
      grok {
        match => { "request" => "%{WORD:method} (/app[1-3])/? HTTP/%{NUMBER:http_version}" }
        tag_on_failure => ["grok_failure_service_detection"]
      }

      if [1] {
        mutate { add_field => { "target_service" => "%{[1]}" } }
      } else {
        mutate { add_field => { "target_service" => "unknown" } }
      }
    }

    # Conversione timestamp
    date {
      match => [ "timestamp", "ISO8601" ]
      target => "@timestamp"
    }

    # Conversioni numeriche
    mutate {
      convert => { "status" => "integer" }
      convert => { "body_bytes_sent" => "integer" }
      convert => { "request_time" => "float" }
      convert => { "upstream_response_time" => "float" }
      convert => { "request_length" => "integer" }
      convert => { "connection_requests" => "integer" }
    }
  }

  # Filtri per log di errore Nginx
  if [type] == "nginx_error" {
    grok {
      match => {
        "message" => "%{DATESTAMP:timestamp} \[%{LOGLEVEL:log_level}\] %{POSINT:pid}#%{NUMBER:tid}: (\*%{NUMBER:connection_id} )?%{GREEDYDATA:error_message}"
      }
      tag_on_failure => ["grok_failure_nginx_error"]
    }

    mutate {
      add_field => { "service" => "nginx-proxy" }
      add_field => { "environment" => "development" }
      add_field => { "log_source" => "nginx_error" }
    }

    date {
      match => [ "timestamp", "yyyy/MM/dd HH:mm:ss" ]
      target => "@timestamp"
    }
  }

  # Filtri per log personalizzati
  if [type] == "custom_log" {
    mutate {
      add_field => { "environment" => "development" }
      add_field => { "log_source" => "custom_http" }
    }
  }

  # GeoIP per analisi geografica (opzionale)
  if [remote_addr] and [remote_addr] != "127.0.0.1" and [remote_addr] != "localhost" {
    geoip {
      source => "remote_addr"
      target => "geoip"
    }
  }

  # User Agent parsing
  if [http_user_agent] {
    useragent {
      source => "http_user_agent"
      target => "user_agent"
    }
  }

  # Rimozione campi non necessari
  mutate {
    remove_field => [ "host", "path" ]
  }
}

output {
  # Output verso Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "nginx-logs-%{+YYYY.MM.dd}"
    template_name => "nginx-logs"
    template_pattern => "nginx-logs-*"
    template => {
      "index_patterns" => ["nginx-logs-*"]
      "settings" => {
        "number_of_shards" => 1
        "number_of_replicas" => 0
        "index.refresh_interval" => "5s"
      }
      "mappings" => {
        "properties" => {
          "@timestamp" => { "type" => "date" }
          "status" => { "type" => "integer" }
          "request_time" => { "type" => "float" }
          "upstream_response_time" => { "type" => "float" }
          "body_bytes_sent" => { "type" => "long" }
          "remote_addr" => { "type" => "ip" }
          "geoip.location" => { "type" => "geo_point" }
        }
      }
    }
  }

  # Output su stdout per debugging (rimuovi in produzione)
  stdout {
    codec => rubydebug
  }
}
