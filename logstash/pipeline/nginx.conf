input {
  # Lettura file di log Nginx
  file {
    path => "/var/log/nginx/access.log"
    start_position => "beginning"
    sincedb_path => "/usr/share/logstash/sincedb_nginx_access"
    codec => "json"
    type => "nginx_access"
    tags => ["nginx", "access", "proxy"]
  }

  file {
    path => "/var/log/nginx/error.log"
    start_position => "beginning"
    sincedb_path => "/usr/share/logstash/sincedb_nginx_error"
    type => "nginx_error"
    tags => ["nginx", "error", "proxy"]
  }

  # Input HTTP per log personalizzati
  http {
    port => 5000
    codec => json
    type => "custom_log"
    tags => ["custom", "http"]
  }

  # Input per Beats
  beats {
    port => 5044
    type => "beats"
  }
}

filter {
  # Filtri per log di accesso Nginx (JSON)
  if [type] == "nginx_access" {
    mutate {
      add_field => { "service" => "nginx-proxy" }
      add_field => { "environment" => "development" }
      add_field => { "log_source" => "nginx_access" }
    }

    # Parsing dello status code per categorizzazione
    if [status] {
      if [status] >= 200 and [status] < 300 {
        mutate { add_field => { "status_category" => "success" } }
      } else if [status] >= 300 and [status] < 400 {
        mutate { add_field => { "status_category" => "redirect" } }
      } else if [status] >= 400 and [status] < 500 {
        mutate { add_field => { "status_category" => "client_error" } }
      } else if [status] >= 500 {
        mutate { add_field => { "status_category" => "server_error" } }
      }
    }

    # Conversione timestamp
    date {
      match => [ "timestamp", "ISO8601" ]
      target => "@timestamp"
    }

    # Conversioni numeriche
    mutate {
      convert => { "status" => "integer" }
      convert => { "body_bytes_sent" => "integer" }
      convert => { "request_time" => "float" }
      convert => { "upstream_response_time" => "float" }
    }
  }

  # Filtri per log di errore Nginx
  if [type] == "nginx_error" {
    grok {
      match => {
        "message" => "%{DATESTAMP:timestamp} \[%{LOGLEVEL:log_level}\] %{POSINT:pid}#%{NUMBER:tid}: (\*%{NUMBER:connection_id} )?%{GREEDYDATA:error_message}"
      }
      tag_on_failure => ["grok_failure_nginx_error"]
    }

    mutate {
      add_field => { "service" => "nginx-proxy" }
      add_field => { "environment" => "development" }
      add_field => { "log_source" => "nginx_error" }
    }

    date {
      match => [ "timestamp", "yyyy/MM/dd HH:mm:ss" ]
      target => "@timestamp"
    }
  }

  # Filtri per log personalizzati
  if [type] == "custom_log" {
    mutate {
      add_field => { "environment" => "development" }
      add_field => { "log_source" => "custom_http" }
    }
  }

  # Rimozione campi non necessari
  mutate {
    remove_field => [ "host", "path" ]
  }
}

output {
  # Output verso Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "nginx-logs-%{+YYYY.MM.dd}"
  }

  # Output su stdout per debugging
  stdout {
    codec => rubydebug
  }
}
